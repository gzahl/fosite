fosite - 2D hydrodynamical simulation program
--------------------------------------------


1. INTRODUCTION

Fosite is a 2D hydrodynamical simulation code written in FORTRAN 90/95. It
is based on a numerical scheme for the solution of nonlinear hyperbolic
conservation laws first introduced by Kurganov and Tadmor (Refs.:
J. of Comp. Phys., vol. 160, pp. 241, 2000; Num. Meth. for PDEs,
vol. 18, pp. 561, 2002). This method has been extended from Cartesian
to general orthogonal grids (Ref.: T. Illenseer, PhD Thesis (German),
University of Heidelberg, 2006; Illenseer and Duschl, arXiv:0804.2979 
[physics.comp-ph], 2008). This version is a reimplementation of the
adv2D program available at

   http://archiv.ub.uni-heidelberg.de/volltextserver/volltexte/2007/7046/zip/adv2D.zip

I wrote for my PhD thesis. It utilzes the object-oriented (OO) design patterns
described by Decyk and Gardner (Ref.: Comput. Phys. Comm., vol. 178(8), pp.
611). Hence fosite incorporates the flexibility of OO-programming into
Fortran 90/95 and preserves efficiency of the numerical computation.

Although the core program is capable of dealing with almost any 2D advection
problems the code shipped with this README solves only hydrodynamical
problems with and without viscosity. So far the physics module can deal with
2D problems and 2.5D problems with angular momentum transport. The ideal gas 
equation of state with constant ratio of specific heat capacities is
implemented for both 2D and 2.5D simulations. Various curvilinear grids are
supported including polar, cylindrical and spherical geometries. There are
two simple file formats for output data files. It could be either plain ASCII
with the results for each variable given in columns with a block structure or
simple binary data (see section 6. of this README). GNUPLOT is capable of reading
both formats (for binary input you need at least version 4.2). Native OpenDX output
has been removed in favor of netcdf, because OpenDX is capable of reading data files
written with the netcdf output module of fosite. Since version 0.3 of fosite
the VTK file format is supported (see http://www.vtk.org). Parallel output is using
MPI-IO is possible with all file formats. We strongly recommend to use one of
the binary formats for best performance and avoid data output to NFS file systems.

2. MAKE & COMPILING

Although all source files have the extension .f90 the code uses some
FORTRAN 95 extensions and therefore only compiles with a Fortran 95
compiler.
To customize the build process enter the directory with the source code
and run

   ./configure

For a list of command line arguments of the configure script type

   ./configure --help

The configure-script should find and set the variables FC, FCFLAGS and LDFLAGS.
FC should point to your Fortran 95 compiler and FCFLAGS should contain some
appropriate command line arguments for the compile command.
These variables can be manually set by typing

   ./configure FC=<your compiler>

<your compiler> can be sxf90, ifort, g95, mpif90, gfortran, etc.
Then type

   make

at the command line. At the end of the build process there should be
a new executable file named fosite in the directory. Type

   ./fosite

to start the calculation.
The code has been verified to compile with the Intel(R) Fortran Compiler
(vers. 8.x and 9.x (default)), GNU fortran compiler (vers. 4.1.0),
g95 (vers. 4.0.3) on various Linux boxes and NEC sxf90 (Rev.360 2006/11/30)
cross compiler for NEC SX-8 vector supercomputers. If the program aborts immediately
after initialization with a segmentation fault, try to increase the stack size
(ulimit -s unlimited).

3. COMPILING PARALLEL VERSION (optional)

The parallel version of fosite uses the MPI2 librarys which have to be installed first.
To use it type

   ./configure --with-mpi

If the MPI2 librarys are located in a different directory than the regular directory,
you have to set the path by using

   ./configure --with-mpi=[MPI_DIR]

where [MPI_DIR] is the MPI2 installation directory. For parallel I/O it is strongly
recommended to use a parallel file system like PVFS2 (http://www.pvfs.org)
with binary output for best performance. In this case it might be necessary to
tell the configure script the pvfs2 installation directory

  ./configure --with-mpi=[MPI_DIR] --with-pvfs2=[PVFS2_DIR]

If the configure script fails maybe the easiest way to proceed is to specify
the MPI Fortran compiler command

  ./configure FC=mpif90 --with-mpi

If there is still something going wrong check the error messages in the file
"config.log" generated by the configure script in the same directory.
To compile the parallel version of Fosite type

   make parallel

Sometimes it's usefull to prevent gfortran from buffering all output to
the terminal. Otherwise you will probably get the programs informative
output normally written to standard output (i.e. the terminal) after the
last MPI process has finished its job. To force fosite to write all
runtime information directly to standard output type
   export GFORTRAN_UNBUFFERED_PRECONNECTED=Y
(bash) or
   setenv GFORTRAN_UNBUFFERED_PRECONNECTED Y
(csh) before compiling. Remember, this is only necessary if you are
using the GNU fortran compiler gfortran.

The parallel code of Fosite has been verified to compile with the mpich2
implementation (version 1.0.6 & 1.0.8) of MPI others may work too.

4. SIMPLE CUSTOMIZATION

Maybe the best way to learn how to customize the code is to take a look
at the init files in the examples subdirectory. To use one of them
copy it into the base directory

  cp examples/init_gauss3d.f90 ./init.f90

or generate a symbolic link

  ln -sf examples/init_gauss3d.f90 ./init.f90

rebuild the program and run it. The initialization module contains
at least 2 subroutines which can be modified by the user.

   InitProgram: set control variables
   InitData: set initial conditions

For a short description of some control variables take a look at the
example files.


5. ADVANCED CUSTOMIZATION

Because of the modular structure of the code it is possible to introduce
completely new physics with comparatively little effort. Take a look at
these subdirectories to add new features:

  boundary: add new boundary conditions
  mesh:     geometry of the mesh
  fluxes:   flux functions and reconstruction processes
  physics:  change physical fluxes (i.e eigenvalues of the advection problem)
  sources:  add new/modify existing source terms
  io:       add support for new input/output data file formats

According to the OO-design patterns there is a generic module (e.g.
geometry_generic) for almost any task. These modules can be considered
as an interface between the basic modules (e.g. geometry_cartesian,
geometry_polar, etc.) and the program. The data structures connected to
the modules can be found in the subdirectory "common".
To add a new feature follow these four steps:
1. Create a new basic module in the particular subdirectory
   (e.g. geometry_mygeo.f90 in ./mesh) using the existing modules as
   a template.
2. Edit the generic module and add a USE instruction with your new module
   to the header.Then define a new flag as an integer constant
   (e.g. INTEGER, PARAMETER :: MYGEO = 100) and customize the
   generic subroutines and functions. There are SELECT .. CASE
   branch instructions in which the specific routines are called.
3. Modify your initilization file init.f90 to use the new
   feature (e.g. CALL InitMesh(Mesh,Fluxes,MYGEO,..)).
4. To compile the program with the new feature you have to add
   an entry to the Makefile in the directory under consideration
   (e.g. ./mesh/Makefile) to be sure the new module is compiled
   before the generic module. Rebuild the whole program by doing
   a "make distclean" first and then enter "make".


6. DATA OUTPUT AND FILE FORMATS

6.1 Simple binary output

 Specification: header - data - bflux - timestamp - data - bflus - timestamp - ....
  header   : (4 + 10 * sizeof(INTEGER) + 10 * sizeof(REAL) + 4) bytes
  data     : (4 + sizeof(REAL) * INUM * JNUM * (2+VNUM) + 4) bytes
  bflux    : (4 + sizeof(REAL) * 4 * VNUM + 4) bytes
  timestamp: (4 + sizeof(REAL) + 4) bytes
  the leading and trailing 4 bytes are caused by the Fortran output

 Example: 
  Physics: Euler3D -> VNUM=5; Mesh: 200x350;
  compiled with AUTODOUBLE -> sizeof(REAL)=8, sizeof(INTEGER)=4
   -> header   : 4+40+80+4 = 128 bytes
   -> data     : 4+8*200*350*7+4=3920008 bytes
                 first data set starts at 128+4 = 132 bytes
   -> bflux    : 4+8*4*5+4 = 168 bytes
   -> timestamp: 4+8+4 = 16 bytes

6.2 How to plot binary data with Gnuplot

 to plot Z over X and Y
 
    (s)plot "FILENAME" binary \
       skip=sizeof(HEADER+4)+timestep*sizeof(DATA+BFLUX+TIMESTAMP) \
       record=INUMxJNUM format="FORMATSTRING" using X:Y(:Z)

 FORMATSTRING is %f*(2+VNUM) or %lf*(2+VNUM)

 Example:
  to plot 23. timestep of example above
  
     iter = 23
     splot "tci-ta3800-nl.bin" binary skip=132 + iter * (3920008+168+16) \
        record=200x350 format="%lf%lf%lf%lf%lf%lf%lf" u 1:2:3

6.3 Output with VTK on NecSX8 and NecSX9

 VTK needs a C-conformable output. To ensure this on NecSX8 and NecSX9:
 set
     export F_NORCW= UNITNUMBER
 as environment variable (in NQS-Skript).
 Also set 
     CALL InitFileIO(..., unit = UNITNUMBER,...)
 in your init.f90 file. UNITNUMBER is a integer. Ensure, that this unit
 number is unique. (save way: UNITNUMBER > 1000)
 

The code is distributed under the GNU General Public License - see the
accompanying LICENSE file for more details. So feel free to experiment
with this.

Copyright (C) 2006-2010 Tobias Illenseer <tillense@astrophysik.uni-kiel.de>



  
