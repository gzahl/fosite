fosite - 2D hydrodynamical simulation program
--------------------------------------------


1. INTRODUCTION

Fosite is a 2D hydrodynamical simulation code written in FORTRAN 90/95. It
is based on a numerical scheme for the solution of nonlinear hyperbolic
conservation laws first introduced by Kurganov and Tadmor (Refs.:
J. of Comp. Phys., vol. 160, pp. 241, 2000; Num. Meth. for PDEs,
vol. 18, pp. 561, 2002). This method has been extended from Cartesian
to general orthogonal grids (Ref.: T. Illenseer, PhD Thesis (German),
University of Heidelberg, 2006; Illenseer and Duschl, arXiv:0804.2979 
[physics.comp-ph], 2008). This version is a reimplementation of the
adv2D program available at

   http://archiv.ub.uni-heidelberg.de/volltextserver/volltexte/2007/7046/zip/adv2D.zip

I wrote for my PhD thesis. It utilzes the object-oriented (OO) design patterns
described by Decyk and Gardner (Ref.: Comput. Phys. Comm., vol. 178(8), pp.
611). Hence fosite incorporates the flexibility of OO-programming into
Fortran 90/95 and preserves efficiency of the numerical computation.

Although the core program is capable of dealing with almost any 2D advection
problems the code shipped with this README solves only hydrodynamical
problems with and without viscosity. So far the physics module can deal with
2D problems and 2.5D problems with angular momentum transport. The ideal gas 
equation of state with constant ratio of specific heat capacities is
implemented for both 2D and 2.5D simulations. Various curvilinear grids are
supported including polar, cylindrical and spherical geometries. The data file
for the output can either be simple in columns with a block structure or in
binary. GNUPLOT is capable of reading both formats (for binary input you need
at least version 4.2). OpenDX output has been removed and HDF5 is not yet
implemented.


2. MAKE & COMPILING

Although all source files have the extension .f90 the code uses some
FORTRAN 95 extensions and therefore only compiles with a Fortran 95
compiler.
To customize the build process enter the directory with the source code
and run

   ./configure

For a list of command line arguments of the configure script type

   ./configure --help

The configure-script should find and set the variables FC, FCFLAGS and LDFLAGS.
FC should point to your Fortran 95 compiler and FCFLAGS should contain some
appropriate command line arguments for the compile command.
These variables can be manually set by typing

   ./configure FC=<your compiler>

<your compiler> can be sxf90, ifort, g95, mpif90, gfortran, etc.
Then type

   make

at the command line. At the end of the build process there should be
a new executable file named fosite in the directory. Type

   ./fosite

to start the calculation.
The code has been verified to compile with the Intel(R) Fortran Compiler
(vers. 8.x and 9.x (default)), GNU fortran compiler (vers. 4.1.0),
g95 (vers. 4.0.3) on various Linux boxes and NEC sxf90 (Rev.360 2006/11/30)
cross compiler for NEC SX-8 vector supercomputers. If the program aborts immediately
after initialization with a segmentation fault, try to increase the stack size
(ulimit -s unlimited).

3. COMPILING PARALLEL VERSION (optional)

The parallel version of fosite uses the MPI2 librarys which have to be installed first.
To use it type

   ./configure --with-mpi

If the MPI2 librarys are located in a different directory than the regular directory,
you have to set the path by using

   ./configure --with-mpi=[MPI_DIR]

where [MPI_DIR] is the MPI2 installation directory. For parallel I/O it is strongly
recommended to use a parallel file system like PVFS2 (http://www.pvfs.org)
with binary output for best performance. In this case it might be necessary to
tell the configure script the pvfs2 installation directory

  ./configure --with-mpi=[MPI_DIR] --with-pvfs2=[PVFS2_DIR]

If the configure script fails maybe the easiest way to proceed is to specify
the MPI Fortran compiler command

  ./configure FC=mpif90 --with-mpi

If there is still something going wrong check the error messages in the file
"config.log" generated by the configure script in the same directory.
To compile the parallel version of Fosite type

   make parallel

Sometimes gfortran buffers output to screen in parallel mode. To prevent it type
   export GFORTRAN_UNBUFFERED_ALL=Y
before compile fosite.
The parallel code of Fosite has been verified to compile with the mpich2
(version 1.0.6) implementation of MPI others may work too.

4. SIMPLE CUSTOMIZATION

Maybe the best way to learn how to customize the code is to take a look
at the example setups in the examples subdirectory. To use one of them
copy it into the base directory

  cp examples/init_gauss3d.f90 ./init.f90

rebuild the program and run it. The initialization module contains
at least 2 subroutines which can be modified by the user.

   InitProgram: set control variables
   InitData: set initial conditions

For a short description of some control variables take a look at the file
types.f90 (deprecated) and files in the "common" subdirectory.


5. ADVANCED CUSTOMIZATION

Because of the modular structure of the code it is possible to introduce
completely new physics with comparatively little effort. Take a look at
these subdirectories to add new features:

  boundary: add new boundary conditions
  mesh:     geometry of the mesh
  fluxes:   flux functions and reconstruction processes
  physics:  change physical fluxes (i.e eigenvalues of the advection problem)
  sources:  add new/modify existing source terms

According to the OO-design patterns there is a generic module (e.g.
geometry_generic) for almost any task. These modules can be considered
as an interface between the basic modules (e.g. geometry_cartesian,
geometry_polar, etc.) and the program. The data structures connected to
the modules can be found in the subdirectory "common".
To add a new feature follow these four steps:
1. Create a new basic module in the particular subdirectory
   (e.g. geometry_mygeo.f90 in ./mesh) using the existing modules as
   a template.
2. Edit the generic module and add a USE instruction with your new module
   to the header.Then define a new flag as an integer constant
   (e.g. INTEGER, PARAMETER :: MYGEO = 10) and customize the
   generic subroutines and functions. There are SELECT .. CASE
   branch instructions in which the specific routines are called.
3. Modify your initilization file init.f90 to use the new
   feature (e.g. CALL InitMesh(Mesh,Fluxes,MYGEO,..)).
4. To compile the program with the new feature you have to add
   an entry to the Makefile in the directory under consideration
   (e.g. ./mesh/Makefile) to be sure the new module is compiled
   before the generic module. Rebuild the whole program by doing
   a "make distclean" first and then enter "make".

The code is distributed under the GNU General Public License - see the
accompanying LICENSE file for more details. So feel free to experiment
with this.

6. Output Format - binary

 Specification: header - data - timestamp - data - timestamp - ....
  header   : (4 + 10 * sizeof(INTEGER) + 10 * sizeof(REAL) + 4) bytes
  data     : (4 + sizeof(REAL) * INUM * JNUM * VNUM + 4) bytes
  timestamp: (4 + sizeof(REAL) + 4) bytes
  the leading and trailing 4 bytes are caused by the Fortran output

 Example: 
  Physics: Euler3D -> VNUM=7; Mesh: 200x350;
  compiled with AUTODOUBLE -> sizeof(REAL)=8, sizeof(INTEGER)=4
   -> header   : 4+40+80+4 = 128 bytes
   -> data     : 4+8*200*350*7+4=3920008 bytes
                 first data set starts at 128+4 = 132 bytes
   -> timestamp: 4+8+4 = 16 bytes

6.1 How to plot binary data with Gnuplot

 to plot Z over X and Y
 
    (s)plot "FILENAME" binary \
       skip=sizeof(HEADER+4)+timestep*sizeof(DATA+TIMESTAMP) \
       record=INUMxJNUM format="FORMATSTRING" using X:Y(:Z)

 FORMATSTRING is %f*VNUM or %lf*VNUM

 Example:
  to plot 23. timestep of example above
  
     iter = 23
     splot "tci-ta3800-nl.bin" binary skip=132 + iter * (3920008+16) \
        record=200x350 format="%lf%lf%lf%lf%lf%lf%lf" u 1:2:3


Copyright (C) 2006-2009 Tobias Illenseer <tillense@astrophysik.uni-kiel.de>



  
